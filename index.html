<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Game</title>
    <style>
        :root {
            --neon-pink: #ff00c3;
            --neon-cyan: #3cf9ff;
            --deep-purple: #19003a;
            --night-sky: #05010a;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', 'Trebuchet MS', sans-serif;
            background-color: var(--night-sky);
            color: #f7f8ff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        #galaxy-canvas {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            pointer-events: none;
            background: radial-gradient(circle at center, rgba(12, 0, 36, 0.6), rgba(0, 0, 0, 0.9));
        }

        .game-container {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 30px 40px 35px;
            background: rgba(18, 5, 48, 0.8);
            border-radius: 18px;
            border: 2px solid rgba(255, 0, 195, 0.65);
            box-shadow: 0 0 45px rgba(255, 0, 195, 0.55), 0 0 75px rgba(60, 249, 255, 0.35);
            backdrop-filter: blur(4px);
        }

        .game-container::before {
            content: "";
            position: absolute;
            inset: 6px;
            border-radius: 12px;
            border: 1px solid rgba(60, 249, 255, 0.3);
            pointer-events: none;
            box-shadow: inset 0 0 22px rgba(60, 249, 255, 0.15);
        }

        h1 {
            margin: 0 0 20px;
            font-size: 42px;
            letter-spacing: 6px;
            text-transform: uppercase;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px rgba(60, 249, 255, 0.7), 0 0 25px rgba(255, 0, 195, 0.4);
            animation: titleGlow 4s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% {
                text-shadow: 0 0 10px rgba(60, 249, 255, 0.9), 0 0 30px rgba(255, 0, 195, 0.4);
                color: var(--neon-cyan);
            }
            50% {
                text-shadow: 0 0 20px rgba(255, 0, 195, 0.9), 0 0 45px rgba(60, 249, 255, 0.35);
                color: var(--neon-pink);
            }
        }

        .info-panel {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 16px;
            width: 100%;
            margin-bottom: 18px;
        }

        .info-card {
            background: rgba(10, 0, 32, 0.65);
            border-radius: 10px;
            padding: 12px 16px;
            border: 1px solid rgba(255, 0, 195, 0.35);
            box-shadow: inset 0 0 14px rgba(60, 249, 255, 0.18);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 120px;
        }

        .info-card .label {
            font-size: 12px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            color: rgba(247, 248, 255, 0.65);
            margin-bottom: 6px;
        }

        .info-card .value {
            font-size: 22px;
            color: #ffffff;
            text-shadow: 0 0 12px rgba(60, 249, 255, 0.6);
        }

        .info-card.flash {
            animation: cardFlash 0.6s ease;
        }

        @keyframes cardFlash {
            0% {
                box-shadow: 0 0 32px rgba(60, 249, 255, 0.9), inset 0 0 24px rgba(255, 0, 195, 0.45);
                transform: translateY(-2px);
            }
            100% {
                box-shadow: inset 0 0 14px rgba(60, 249, 255, 0.18);
                transform: none;
            }
        }

        #tetris {
            background: rgba(0, 0, 0, 0.92);
            border: 3px solid rgba(255, 0, 195, 0.4);
            box-shadow: inset 0 0 25px rgba(60, 249, 255, 0.2), 0 0 22px rgba(255, 0, 195, 0.25);
            margin-bottom: 20px;
        }

        button {
            margin-top: 12px;
            padding: 12px 36px;
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 2px;
            text-transform: uppercase;
            background: linear-gradient(135deg, rgba(255, 0, 195, 0.9), rgba(60, 249, 255, 0.85));
            color: #0b001a;
            border: none;
            border-radius: 999px;
            cursor: pointer;
            box-shadow: 0 0 25px rgba(255, 0, 195, 0.6), 0 0 45px rgba(60, 249, 255, 0.35);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        button:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 0 35px rgba(255, 0, 195, 0.8), 0 0 65px rgba(60, 249, 255, 0.45);
        }

        button:focus {
            outline: none;
        }

        @media (max-width: 640px) {
            .game-container {
                padding: 24px;
            }

            .info-panel {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 32px;
            }
        }
    </style>
</head>
<body>
    <canvas id="galaxy-canvas"></canvas>
    <div class="game-container">
        <h1>Tetris</h1>
        <div class="info-panel">
            <div class="info-card">
                <div class="label">Score</div>
                <div class="value" id="score">0</div>
            </div>
            <div class="info-card">
                <div class="label">Level</div>
                <div class="value" id="level">1</div>
            </div>
            <div class="info-card">
                <div class="label">Next Level In</div>
                <div class="value" id="next-level-points">1000</div>
            </div>
        </div>
        <canvas id="tetris" width="240" height="400"></canvas>
        <button id="start-button">Start Game</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('tetris');
            const ctx = canvas.getContext('2d');
            const scoreElement = document.getElementById('score');
            const levelElement = document.getElementById('level');
            const nextLevelElement = document.getElementById('next-level-points');
            const startButton = document.getElementById('start-button');
            const galaxyCanvas = document.getElementById('galaxy-canvas');
            const galaxyCtx = galaxyCanvas.getContext('2d');

            const scoreCard = scoreElement.closest('.info-card');
            const levelCard = levelElement.closest('.info-card');
            const nextLevelCard = nextLevelElement.closest('.info-card');

            const ROWS = 20;
            const COLS = 12;
            const BLOCK_SIZE = 20;
            const EMPTY = 'transparent';

            const STAR_COUNT = 220;
            let stars = [];
            let galaxyWidth = window.innerWidth;
            let galaxyHeight = window.innerHeight;
            let pixelRatio = window.devicePixelRatio || 1;

            let board = [];
            let currentPiece = null;
            let score = 0;
            let level = 1;
            let gameOver = false;
            let intervalId = null;
            let audioCtx = null;

            const PIECES = [
                [I, '#3cf9ff'],
                [J, '#00b1ff'],
                [L, '#ff7b1c'],
                [O, '#ffeb3b'],
                [S, '#00ffb8'],
                [T, '#d76bff'],
                [Z, '#ff3c6f']
            ];

            function I() {
                return [
                    [0, 0, 0, 0],
                    [1, 1, 1, 1],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ];
            }

            function J() {
                return [
                    [1, 0, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ];
            }

            function L() {
                return [
                    [0, 0, 1],
                    [1, 1, 1],
                    [0, 0, 0]
                ];
            }

            function O() {
                return [
                    [1, 1],
                    [1, 1]
                ];
            }

            function S() {
                return [
                    [0, 1, 1],
                    [1, 1, 0],
                    [0, 0, 0]
                ];
            }

            function T() {
                return [
                    [0, 1, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ];
            }

            function Z() {
                return [
                    [1, 1, 0],
                    [0, 1, 1],
                    [0, 0, 0]
                ];
            }

            function ensureAudioContext() {
                if (!audioCtx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (AudioContext) {
                        audioCtx = new AudioContext();
                    }
                } else if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            }

            function playLineClearSound(rowsCleared) {
                if (!audioCtx) {
                    return;
                }

                const now = audioCtx.currentTime;

                for (let i = 0; i < rowsCleared; i++) {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'square';

                    const startTime = now + i * 0.12;
                    const baseFrequency = 320 + i * 110;

                    osc.frequency.setValueAtTime(baseFrequency, startTime);
                    osc.frequency.exponentialRampToValueAtTime(baseFrequency * 2, startTime + 0.1);

                    gain.gain.setValueAtTime(0.25, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.25);

                    osc.connect(gain).connect(audioCtx.destination);
                    osc.start(startTime);
                    osc.stop(startTime + 0.26);
                }
            }

            function flashCard(card) {
                if (!card) return;
                card.classList.remove('flash');
                void card.offsetWidth;
                card.classList.add('flash');
            }

            function resizeGalaxy() {
                pixelRatio = window.devicePixelRatio || 1;
                galaxyWidth = window.innerWidth;
                galaxyHeight = window.innerHeight;
                galaxyCanvas.width = galaxyWidth * pixelRatio;
                galaxyCanvas.height = galaxyHeight * pixelRatio;
                galaxyCanvas.style.width = '100vw';
                galaxyCanvas.style.height = '100vh';
                galaxyCtx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            }

            function createStars() {
                const blackHoleRadius = Math.min(galaxyWidth, galaxyHeight) * 0.18;
                const maxRadius = Math.sqrt(galaxyWidth * galaxyWidth + galaxyHeight * galaxyHeight) / 2;

                stars = Array.from({ length: STAR_COUNT }, () => {
                    const radius = blackHoleRadius + Math.random() * (maxRadius - blackHoleRadius);
                    return {
                        angle: Math.random() * Math.PI * 2,
                        radius,
                        speed: 0.002 + Math.random() * 0.004,
                        inwardSpeed: 0.02 + Math.random() * 0.04,
                        size: 0.6 + Math.random() * 1.8,
                        offset: Math.random() * Math.PI * 2,
                        maxRadius
                    };
                });
            }

            function animateGalaxy() {
                requestAnimationFrame(animateGalaxy);

                const width = galaxyWidth;
                const height = galaxyHeight;
                const cx = width / 2;
                const cy = height / 2;
                const blackHoleRadius = Math.min(width, height) * 0.18;
                const time = performance.now() * 0.001;

                galaxyCtx.fillStyle = 'rgba(3, 0, 18, 0.28)';
                galaxyCtx.fillRect(0, 0, width, height);

                const gradient = galaxyCtx.createRadialGradient(cx, cy, 0, cx, cy, blackHoleRadius * 1.6);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0.95)');
                gradient.addColorStop(0.45, 'rgba(24, 0, 56, 0.7)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                galaxyCtx.fillStyle = gradient;
                galaxyCtx.beginPath();
                galaxyCtx.arc(cx, cy, blackHoleRadius * 1.6, 0, Math.PI * 2);
                galaxyCtx.fill();

                galaxyCtx.save();
                galaxyCtx.translate(cx, cy);
                galaxyCtx.rotate(time * 0.25);
                galaxyCtx.strokeStyle = 'rgba(60, 249, 255, 0.08)';
                galaxyCtx.lineWidth = 1.4;
                for (let i = 1; i <= 3; i++) {
                    galaxyCtx.beginPath();
                    galaxyCtx.ellipse(0, 0, blackHoleRadius * (1.1 + i * 0.38), blackHoleRadius * (0.6 + i * 0.28), 0, 0, Math.PI * 2);
                    galaxyCtx.stroke();
                }
                galaxyCtx.restore();

                galaxyCtx.save();
                galaxyCtx.globalCompositeOperation = 'lighter';

                stars.forEach((star) => {
                    star.angle += star.speed;
                    const pull = star.inwardSpeed + star.speed * 30;
                    star.radius -= pull;

                    if (star.radius < blackHoleRadius * 0.55) {
                        star.radius = blackHoleRadius + Math.random() * (star.maxRadius - blackHoleRadius);
                        star.angle = Math.random() * Math.PI * 2;
                    }

                    const x = cx + Math.cos(star.angle) * star.radius;
                    const y = cy + Math.sin(star.angle) * star.radius;
                    const doppler = Math.sin(star.angle + time * 3 + star.offset);
                    const hue = 200 + doppler * 120;
                    const alpha = 0.45 + (1 - star.radius / star.maxRadius) * 0.4;
                    const size = star.size * (1 + (blackHoleRadius / Math.max(star.radius, 1)) * 0.5);

                    galaxyCtx.beginPath();
                    galaxyCtx.fillStyle = `hsla(${hue}, 90%, 65%, ${alpha})`;
                    galaxyCtx.arc(x, y, size, 0, Math.PI * 2);
                    galaxyCtx.fill();

                    galaxyCtx.beginPath();
                    galaxyCtx.strokeStyle = `hsla(${hue}, 90%, 75%, ${alpha * 0.5})`;
                    galaxyCtx.lineWidth = size * 0.6;
                    galaxyCtx.moveTo(x, y);
                    galaxyCtx.lineTo(
                        cx + Math.cos(star.angle - 0.22) * (star.radius + size * 4),
                        cy + Math.sin(star.angle - 0.22) * (star.radius + size * 4)
                    );
                    galaxyCtx.stroke();
                });

                galaxyCtx.restore();

                galaxyCtx.beginPath();
                galaxyCtx.lineWidth = 2.2;
                galaxyCtx.strokeStyle = 'rgba(60, 249, 255, 0.22)';
                galaxyCtx.arc(cx, cy, blackHoleRadius * 0.88, 0, Math.PI * 2);
                galaxyCtx.stroke();
            }

            function createBoard() {
                board = Array.from({ length: ROWS }, () => Array(COLS).fill(EMPTY));
            }

            function drawSquare(x, y, color) {
                const px = x * BLOCK_SIZE;
                const py = y * BLOCK_SIZE;

                if (color === EMPTY) {
                    ctx.fillStyle = 'rgba(8, 0, 25, 0.55)';
                    ctx.fillRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
                    ctx.strokeStyle = 'rgba(60, 249, 255, 0.08)';
                    ctx.strokeRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
                    return;
                }

                ctx.fillStyle = color;
                ctx.fillRect(px, py, BLOCK_SIZE, BLOCK_SIZE);

                const highlight = ctx.createLinearGradient(px, py, px + BLOCK_SIZE, py + BLOCK_SIZE);
                highlight.addColorStop(0, 'rgba(255, 255, 255, 0.35)');
                highlight.addColorStop(0.3, 'rgba(255, 255, 255, 0.12)');
                highlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = highlight;
                ctx.fillRect(px, py, BLOCK_SIZE, BLOCK_SIZE);

                const gloss = ctx.createLinearGradient(px, py, px, py + BLOCK_SIZE);
                gloss.addColorStop(0, 'rgba(255, 255, 255, 0.22)');
                gloss.addColorStop(0.6, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gloss;
                ctx.fillRect(px, py, BLOCK_SIZE, BLOCK_SIZE / 1.8);

                ctx.lineWidth = 1.2;
                ctx.strokeStyle = 'rgba(12, 0, 32, 0.85)';
                ctx.strokeRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
            }

            function drawBoard() {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        drawSquare(c, r, board[r][c]);
                    }
                }
            }

            function randomPiece() {
                const randomIndex = Math.floor(Math.random() * PIECES.length);
                const [pieceFunction, color] = PIECES[randomIndex];
                const shape = pieceFunction();

                return {
                    shape,
                    color,
                    x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
                    y: 0
                };
            }

            function drawPiece() {
                for (let r = 0; r < currentPiece.shape.length; r++) {
                    for (let c = 0; c < currentPiece.shape[r].length; c++) {
                        if (currentPiece.shape[r][c]) {
                            drawSquare(currentPiece.x + c, currentPiece.y + r, currentPiece.color);
                        }
                    }
                }
            }

            function moveDown() {
                if (!collision(0, 1)) {
                    currentPiece.y++;
                } else {
                    lockPiece();
                    removeRows();
                    currentPiece = randomPiece();

                    if (collision(0, 0)) {
                        gameOver = true;
                        currentPiece = null;
                        if (intervalId) {
                            clearInterval(intervalId);
                            intervalId = null;
                        }
                        startButton.textContent = 'Play Again';
                        startButton.style.display = 'inline-block';
                        setTimeout(() => alert(`Game Over! Your score: ${score}`), 50);
                    }
                }
            }

            function moveLeft() {
                if (!collision(-1, 0)) {
                    currentPiece.x--;
                }
            }

            function moveRight() {
                if (!collision(1, 0)) {
                    currentPiece.x++;
                }
            }

            function rotate() {
                const rotated = [];
                const N = currentPiece.shape.length;

                for (let i = 0; i < N; i++) {
                    rotated[i] = [];
                    for (let j = 0; j < N; j++) {
                        rotated[i][j] = currentPiece.shape[N - j - 1][i];
                    }
                }

                const piece = JSON.parse(JSON.stringify(currentPiece));
                piece.shape = rotated;

                if (!collision(0, 0, piece)) {
                    currentPiece = piece;
                }
            }

            function collision(xOffset, yOffset, piece = currentPiece) {
                for (let r = 0; r < piece.shape.length; r++) {
                    for (let c = 0; c < piece.shape[r].length; c++) {
                        if (!piece.shape[r][c]) continue;

                        const newX = piece.x + c + xOffset;
                        const newY = piece.y + r + yOffset;

                        if (newX < 0 || newX >= COLS || newY >= ROWS) {
                            return true;
                        }

                        if (newY < 0) continue;

                        if (board[newY][newX] !== EMPTY) {
                            return true;
                        }
                    }
                }
                return false;
            }

            function lockPiece() {
                for (let r = 0; r < currentPiece.shape.length; r++) {
                    for (let c = 0; c < currentPiece.shape[r].length; c++) {
                        if (!currentPiece.shape[r][c]) continue;

                        if (currentPiece.y + r < 0) {
                            gameOver = true;
                            continue;
                        }

                        board[currentPiece.y + r][currentPiece.x + c] = currentPiece.color;
                    }
                }
            }

            function removeRows() {
                let rowsCleared = 0;

                for (let r = ROWS - 1; r >= 0; r--) {
                    if (board[r].every(cell => cell !== EMPTY)) {
                        rowsCleared++;
                        for (let y = r; y > 0; y--) {
                            board[y] = [...board[y - 1]];
                        }
                        board[0] = Array(COLS).fill(EMPTY);
                        r++;
                    }
                }

                if (rowsCleared > 0) {
                    const previousLevel = level;
                    score += rowsCleared * 100 * level;
                    level = Math.floor(score / 1000) + 1;
                    updateLevelInfo();
                    playLineClearSound(rowsCleared);
                    flashCard(scoreCard);
                    flashCard(nextLevelCard);

                    if (level !== previousLevel) {
                        flashCard(levelCard);
                    }

                    updateDropSpeed();
                }
            }

            function updateLevelInfo() {
                scoreElement.textContent = score;
                levelElement.textContent = level;
                const nextThreshold = level * 1000;
                const remaining = Math.max(0, nextThreshold - score);
                nextLevelElement.textContent = remaining.toString();
            }

            function updateDropSpeed() {
                const dropInterval = Math.max(120, 1000 / level);
                if (intervalId) {
                    clearInterval(intervalId);
                }
                intervalId = setInterval(gameLoop, dropInterval);
            }

            function startGame() {
                createBoard();
                currentPiece = randomPiece();
                score = 0;
                level = 1;
                gameOver = false;
                updateLevelInfo();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBoard();
                drawPiece();
                updateDropSpeed();
                startButton.style.display = 'none';
                startButton.textContent = 'Restart';
            }

            function gameLoop() {
                if (gameOver || !currentPiece) {
                    return;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBoard();
                drawPiece();
                moveDown();
            }

            document.addEventListener('keydown', (e) => {
                if (gameOver || !currentPiece) return;

                const controlKeys = [32, 37, 38, 39, 40];
                if (controlKeys.includes(e.keyCode)) {
                    e.preventDefault();
                }

                switch (e.keyCode) {
                    case 37:
                        moveLeft();
                        break;
                    case 38:
                        rotate();
                        break;
                    case 39:
                        moveRight();
                        break;
                    case 40:
                        moveDown();
                        break;
                    case 32:
                        while (!collision(0, 1)) {
                            currentPiece.y++;
                        }
                        moveDown();
                        break;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBoard();
                if (currentPiece) {
                    drawPiece();
                }
            });

            startButton.addEventListener('click', () => {
                ensureAudioContext();
                startGame();
            });

            window.addEventListener('resize', () => {
                resizeGalaxy();
                createStars();
            });

            resizeGalaxy();
            createStars();
            animateGalaxy();
            createBoard();
            drawBoard();
            updateLevelInfo();
        });
    </script>
</body>
</html>